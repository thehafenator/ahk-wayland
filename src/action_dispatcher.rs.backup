use evdev::{uinput::VirtualDevice, EventType, InputEvent, KeyCode as Key};
use fork::{fork, setsid, Fork};
use log::debug;
use log::error;
use nix::sys::signal;
use nix::sys::signal::{sigaction, SaFlags, SigAction, SigHandler, SigSet};
use std::process::{exit, Command, Stdio};
use std::thread;
use std::time::Duration;

use crate::event::RelativeEvent;
use crate::{action::Action, event::KeyEvent};

pub struct ActionDispatcher {
    // Device to emit events
    device: VirtualDevice,
    // Whether we've called a sigaction for spawning commands or not
    sigaction_set: bool,
}

impl ActionDispatcher {
    pub fn new(device: VirtualDevice) -> ActionDispatcher {
        ActionDispatcher {
            device,
            sigaction_set: false,
        }
    }

    // Execute Actions created by EventHandler. This should be the only public method of ActionDispatcher.
    pub fn on_action(&mut self, action: Action) -> anyhow::Result<()> {
        match action {
            Action::KeyEvent(key_event) => self.on_key_event(key_event)?,
            Action::RelativeEvent(relative_event) => self.on_relative_event(relative_event)?,
            Action::MouseMovementEventCollection(mouse_movement_events) => {
                // Sending all mouse movement events at once, unseparated by synchronization events.
                self.send_mousemovement_event_batch(mouse_movement_events)?;

                // Mouse movement events need to be sent all at once because they would otherwise be separated by a synchronization event¹,
                // which the OS handles differently from two unseparated mouse movement events.
                // For example,
                // a REL_X event², followed by a SYNCHRONIZATION event, followed by a REL_Y event³, followed by a SYNCHRONIZATION event,
                // will move the mouse cursor by a different amount than
                // a REL_X event followed by a REL_Y event followed by a SYNCHRONIZATION event.

                // ¹Because Xremap usually sends events one by one through evdev's "emit" function, which adds a synchronization event during each call.
                // ²Mouse movement along the X (horizontal) axis.
                // ³Mouse movement along the Y (vertical) axis.
            }
            Action::InputEvent(event) => self.send_event(event)?,
            Action::Command(command) => self.run_command(command),
            Action::TextExpansion { trigger_len, replacement, add_space } => {
                // Delete the trigger text
                for _ in 0..trigger_len {
                    let event = KeyEvent::new(Key::KEY_BACKSPACE, crate::event::KeyValue::Press);
                    self.on_key_event(event)?;
                    let event = KeyEvent::new(Key::KEY_BACKSPACE, crate::event::KeyValue::Release);
                    self.on_key_event(event)?;
                }

                // Copy replacement to clipboard and paste
                if let Err(e) = crate::ahk::WaylandTextInjector::copy_to_clipboard(&replacement) {
                    eprintln!("Failed to copy: {}", e);
                } else {
                    if let Err(e) = self.inject_ctrl_v() {
                    
                    // if let Err(e) = self.inject_paste() {
                        thread::sleep(Duration::from_millis(500));
                        eprintln!("Failed to paste: {}", e);
                    }

                    // Send space after if requested
                    if add_space {
                        thread::sleep(Duration::from_millis(20));
                        let space_press = KeyEvent::new(Key::KEY_SPACE, crate::event::KeyValue::Press);
                        self.on_key_event(space_press)?;
                        let space_release = KeyEvent::new(Key::KEY_SPACE, crate::event::KeyValue::Release);
                        self.on_key_event(space_release)?;
                    }
                }
            }
            Action::Delay(duration) => {
                thread::sleep(duration);
            }
        }
        Ok(())
    }

    fn on_key_event(&mut self, event: KeyEvent) -> std::io::Result<()> {
        let event = InputEvent::new_now(EventType::KEY.0, event.code(), event.value());
        self.send_event(event)
    }

    fn on_relative_event(&mut self, event: RelativeEvent) -> std::io::Result<()> {
        let event = InputEvent::new_now(EventType::RELATIVE.0, event.code, event.value);
        self.send_event(event)
    }

    // a function that takes mouse movement events to send in a single batch, unseparated by synchronization events.
    fn send_mousemovement_event_batch(&mut self, eventbatch: Vec<RelativeEvent>) -> std::io::Result<()> {
        let mut mousemovementbatch: Vec<InputEvent> = Vec::new();
        for mouse_movement in eventbatch {
            mousemovementbatch.push(InputEvent::new_now(
                EventType::RELATIVE.0,
                mouse_movement.code,
                mouse_movement.value,
            ));
        }
        self.device.emit(&mousemovementbatch)
    }

    fn send_event(&mut self, event: InputEvent) -> std::io::Result<()> {
        if event.event_type() == EventType::KEY {
            debug!("{}: {:?}", event.value(), Key::new(event.code()))
        }
        self.device.emit(&[event])
    }

    fn run_command(&mut self, command: Vec<String>) {
        if !self.sigaction_set {
            // Avoid defunct processes
            let sig_action = SigAction::new(SigHandler::SigDfl, SaFlags::SA_NOCLDWAIT, SigSet::empty());
            unsafe {
                sigaction(signal::SIGCHLD, &sig_action).expect("Failed to register SIGCHLD handler");
            }
            self.sigaction_set = true;
        }

        debug!("Running command: {command:?}");
        match fork() {
            Ok(Fork::Child) => {
                match fork() {
                    Ok(Fork::Child) => {
                        setsid().expect("Failed to setsid.");
                        match Command::new(&command[0])
                            .args(&command[1..])
                            .stdin(Stdio::null())
                            .stdout(Stdio::null())
                            .stderr(Stdio::null())
                            .spawn()
                        {
                            Ok(child) => {
                                debug!("Process started: {:?}, pid {}", command, child.id());
                                exit(0);
                            }
                            Err(e) => {
                                error!("Error running command: {e:?}");
                                exit(1);
                            }
                        }
                    }
                    Ok(Fork::Parent(_)) => exit(0),
                    Err(e) => {
                        error!("Error spawning process: {e:?}");
                        exit(1);
                    }
                }
            }
            Ok(Fork::Parent(_)) => (),
            Err(e) => error!("Error spawning process: {e:?}"),
        }
    }

    fn inject_ctrl_v(&mut self) -> std::io::Result<()> {
        // Press Ctrl
        // let ctrl_press = KeyEvent::new(Key::KEY_LEFTCTRL, crate::event::KeyValue::Press);
        // self.on_key_event(ctrl_press)?;

        // // Press V
        // let v_press = KeyEvent::new(Key::KEY_V, crate::event::KeyValue::Press);
        // self.on_key_event(v_press)?;

        // // Release V
        // let v_release = KeyEvent::new(Key::KEY_V, crate::event::KeyValue::Release);
        // self.on_key_event(v_release)?;

        // // Release Ctrl
        // let ctrl_release = KeyEvent::new(Key::KEY_LEFTCTRL, crate::event::KeyValue::Release);
        // self.on_key_event(ctrl_release)?;

        // Ok(())
        let ctrl_press = KeyEvent::new(Key::KEY_LEFTCTRL, crate::event::KeyValue::Press);
        self.on_key_event(ctrl_press)?;
        std::thread::sleep(std::time::Duration::from_millis(20));
        
        let v_press = KeyEvent::new(Key::KEY_V, crate::event::KeyValue::Press);
        self.on_key_event(v_press)?;
        std::thread::sleep(std::time::Duration::from_millis(20));
        
        let v_release = KeyEvent::new(Key::KEY_V, crate::event::KeyValue::Release);
        self.on_key_event(v_release)?;
        std::thread::sleep(std::time::Duration::from_millis(20));
        
        let ctrl_release = KeyEvent::new(Key::KEY_LEFTCTRL, crate::event::KeyValue::Release);
        self.on_key_event(ctrl_release)?;
        std::thread::sleep(std::time::Duration::from_millis(50));
        Ok(())
    }

fn inject_paste(&mut self) -> std::io::Result<()> {  // rename or replace inject_ctrl_v
    let shift_press = KeyEvent::new(Key::KEY_LEFTSHIFT, crate::event::KeyValue::Press);
    self.on_key_event(shift_press)?;

    let insert_press = KeyEvent::new(Key::KEY_INSERT, crate::event::KeyValue::Press);
    self.on_key_event(insert_press)?;

    let insert_release = KeyEvent::new(Key::KEY_INSERT, crate::event::KeyValue::Release);
    self.on_key_event(insert_release)?;

    let shift_release = KeyEvent::new(Key::KEY_LEFTSHIFT, crate::event::KeyValue::Release);
    self.on_key_event(shift_release)?;

    Ok(())
}

}