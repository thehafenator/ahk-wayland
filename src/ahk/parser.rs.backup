use crate::ahk::types::*;
use evdev::KeyCode;
use regex::Regex;
use std::path::Path;

pub struct AhkParser {
    hotif_contexts: Vec<String>,
}

impl AhkParser {
    pub fn new() -> Self {
        Self {
            hotif_contexts: Vec::new(),
        }
    }

    pub fn parse_file(&mut self, content: &str) -> Result<AhkConfig, String> {
        let mut hotkeys = Vec::new();
        let mut hotstrings = Vec::new();
        let mut current_context = None;

        for line in content.lines() {
            let line = line.trim();
            
            if line.is_empty() || line.starts_with(';') {
                continue;
            }

            if line.starts_with("#HotIf") {
                current_context = self.parse_hotif(line)?;
                continue;
            }

            if line == "#HotIf" {
                current_context = None;
                continue;
            }

            if line.contains("::") {
                let double_colon_count = line.matches("::").count();
                if double_colon_count >= 2 {
                    if let Some(hotstring) = self.parse_hotstring(line, current_context.clone())? {
                        hotstrings.push(hotstring);
                        continue;
                    }
                }
            }

            if line.contains("::") {
                if let Some(hotkey) = self.parse_hotkey(line, current_context.clone())? {
                    hotkeys.push(hotkey);
                }
            }
        }

        Ok(AhkConfig { hotkeys, hotstrings })
    }

    fn parse_hotif(&mut self, line: &str) -> Result<Option<String>, String> {
        let re = Regex::new(r#"#HotIf\s+(.+)"#).unwrap();
        if let Some(caps) = re.captures(line) {
            Ok(Some(caps[1].to_string()))
        } else {
            Ok(None)
        }
    }

    fn parse_hotstring(&self, line: &str, context: Option<String>) -> Result<Option<AhkHotstring>, String> {
        let re = Regex::new(r"^(:([*?CcOoPpSsIiKkEeXxTtBbZz0-9]*):)?([^:]+)::(.*)$").unwrap();
        
        if let Some(caps) = re.captures(line) {
            let options = caps.get(2).map(|m| m.as_str()).unwrap_or("");
            let trigger = caps[3].to_string();
            let replacement = caps[4].to_string();
            
            Ok(Some(AhkHotstring {
                trigger,
                replacement,
                immediate: options.contains('*'),
                case_sensitive: options.contains('C'),
                context,
            }))
        } else {
            Ok(None)
        }
    }

    fn parse_hotkey(&self, line: &str, context: Option<String>) -> Result<Option<AhkHotkey>, String> {
        let parts: Vec<&str> = line.splitn(2, "::").collect();
        if parts.len() != 2 {
            return Ok(None);
        }

        let hotkey_def = parts[0].trim();
        let action_str = parts[1].trim();

        let (modifiers, key, is_wildcard) = self.parse_key_combo(hotkey_def)?;
        let action = self.parse_action(action_str)?;

        Ok(Some(AhkHotkey {
            modifiers,
            key,
            action,
            context,
            is_wildcard,
        }))
    }

    fn parse_key_combo(&self, combo: &str) -> Result<(Vec<KeyCode>, KeyCode, bool), String> {
        let mut modifiers = Vec::new();
        let mut is_wildcard = false;
        let mut rest = combo;

        while rest.starts_with('~') || rest.starts_with('*') || rest.starts_with('$') {
            if rest.starts_with('~') {
                is_wildcard = true;
                rest = &rest[1..];
            } else if rest.starts_with('*') {
                is_wildcard = true;
                rest = &rest[1..];
            } else if rest.starts_with('$') {
                rest = &rest[1..];
            }
        }

        loop {
            if rest.starts_with('^') {
                modifiers.push(KeyCode::KEY_LEFTCTRL);
                rest = &rest[1..];
            } else if rest.starts_with('!') {
                modifiers.push(KeyCode::KEY_LEFTALT);
                rest = &rest[1..];
            } else if rest.starts_with('+') {
                modifiers.push(KeyCode::KEY_LEFTSHIFT);
                rest = &rest[1..];
            } else if rest.starts_with('#') {
                modifiers.push(KeyCode::KEY_LEFTMETA);
                rest = &rest[1..];
            } else {
                break;
            }
        }

        if rest.contains(" & ") {
            let parts: Vec<&str> = rest.split(" & ").collect();
            if parts.len() == 2 {
                if let Some(mod_key) = string_to_key(parts[0].trim()) {
                    modifiers.push(mod_key);
                }
                let main_key = string_to_key(parts[1].trim())
                    .ok_or_else(|| format!("Unknown key: {}", parts[1]))?;
                return Ok((modifiers, main_key, is_wildcard));
            }
        }

        let key = string_to_key(rest.trim())
            .ok_or_else(|| format!("Unknown key: {}", rest))?;

        Ok((modifiers, key, is_wildcard))
    }

    fn parse_action(&self, action_str: &str) -> Result<AhkAction, String> {
        let s = action_str.trim();

        if let Some(rest) = s.strip_prefix("Run(") {
            if let Some(cmd) = rest.strip_suffix(')') {
                let cmd = cmd.trim().trim_matches(|c| c == '"' || c == '\'');
                let parts: Vec<String> = cmd.split_whitespace().map(String::from).collect();
                return Ok(AhkAction::Run(parts));
            }
        }

        for prefix in ["SendInput ", "SendEvent ", "Send "] {
            if let Some(rest) = s.strip_prefix(prefix) {
                let keys = rest.trim_matches(|c| c == '"' || c == '\'').to_string();
                return Ok(AhkAction::Send(keys));
            }
        }

        if let Some(rest) = s.strip_prefix("Sleep ") {
            if let Ok(ms) = rest.trim().parse::<u64>() {
                return Ok(AhkAction::Sleep(ms));
            }
        }

        if s.starts_with("Media_") || s.starts_with("Volume_") {
            if let Some(key) = string_to_key(s) {
                return Ok(AhkAction::Remap(vec![key]));
            }
        }

        if let Some(key) = string_to_key(s) {
            return Ok(AhkAction::Remap(vec![key]));
        }

        Err(format!("Unknown action: {s}"))
    }
}

pub fn string_to_key(s: &str) -> Option<KeyCode> {
    match s.to_lowercase().as_str() {
        "a" => Some(KeyCode::KEY_A),
        "b" => Some(KeyCode::KEY_B),
        "c" => Some(KeyCode::KEY_C),
        "d" => Some(KeyCode::KEY_D),
        "e" => Some(KeyCode::KEY_E),
        "f" => Some(KeyCode::KEY_F),
        "g" => Some(KeyCode::KEY_G),
        "h" => Some(KeyCode::KEY_H),
        "i" => Some(KeyCode::KEY_I),
        "j" => Some(KeyCode::KEY_J),
        "k" => Some(KeyCode::KEY_K),
        "l" => Some(KeyCode::KEY_L),
        "m" => Some(KeyCode::KEY_M),
        "n" => Some(KeyCode::KEY_N),
        "o" => Some(KeyCode::KEY_O),
        "p" => Some(KeyCode::KEY_P),
        "q" => Some(KeyCode::KEY_Q),
        "r" => Some(KeyCode::KEY_R),
        "s" => Some(KeyCode::KEY_S),
        "t" => Some(KeyCode::KEY_T),
        "u" => Some(KeyCode::KEY_U),
        "v" => Some(KeyCode::KEY_V),
        "w" => Some(KeyCode::KEY_W),
        "x" => Some(KeyCode::KEY_X),
        "y" => Some(KeyCode::KEY_Y),
        "z" => Some(KeyCode::KEY_Z),
        "0" => Some(KeyCode::KEY_0),
        "1" => Some(KeyCode::KEY_1),
        "2" => Some(KeyCode::KEY_2),
        "3" => Some(KeyCode::KEY_3),
        "4" => Some(KeyCode::KEY_4),
        "5" => Some(KeyCode::KEY_5),
        "6" => Some(KeyCode::KEY_6),
        "7" => Some(KeyCode::KEY_7),
        "8" => Some(KeyCode::KEY_8),
        "9" => Some(KeyCode::KEY_9),
        "space" => Some(KeyCode::KEY_SPACE),
        "enter" | "return" => Some(KeyCode::KEY_ENTER),
        "tab" => Some(KeyCode::KEY_TAB),
        "backspace" => Some(KeyCode::KEY_BACKSPACE),
        "delete" | "del" => Some(KeyCode::KEY_DELETE),
        "escape" | "esc" => Some(KeyCode::KEY_ESC),
        "capslock" => Some(KeyCode::KEY_CAPSLOCK),
        "up" => Some(KeyCode::KEY_UP),
        "down" => Some(KeyCode::KEY_DOWN),
        "left" => Some(KeyCode::KEY_LEFT),
        "right" => Some(KeyCode::KEY_RIGHT),
        "home" => Some(KeyCode::KEY_HOME),
        "end" => Some(KeyCode::KEY_END),
        "pageup" | "pgup" => Some(KeyCode::KEY_PAGEUP),
        "pagedown" | "pgdn" => Some(KeyCode::KEY_PAGEDOWN),
        "insert" => Some(KeyCode::KEY_INSERT),
        "f1" => Some(KeyCode::KEY_F1),
        "f2" => Some(KeyCode::KEY_F2),
        "f3" => Some(KeyCode::KEY_F3),
        "f4" => Some(KeyCode::KEY_F4),
        "f5" => Some(KeyCode::KEY_F5),
        "f6" => Some(KeyCode::KEY_F6),
        "f7" => Some(KeyCode::KEY_F7),
        "f8" => Some(KeyCode::KEY_F8),
        "f9" => Some(KeyCode::KEY_F9),
        "f10" => Some(KeyCode::KEY_F10),
        "f11" => Some(KeyCode::KEY_F11),
        "f12" => Some(KeyCode::KEY_F12),
        "f13" => Some(KeyCode::KEY_F13),
        "f14" => Some(KeyCode::KEY_F14),
        "f15" => Some(KeyCode::KEY_F15),
        "f16" => Some(KeyCode::KEY_F16),
        "f17" => Some(KeyCode::KEY_F17),
        "f18" => Some(KeyCode::KEY_F18),
        "f19" => Some(KeyCode::KEY_F19),
        "f20" => Some(KeyCode::KEY_F20),
        "f21" => Some(KeyCode::KEY_F21),
        "f22" => Some(KeyCode::KEY_F22),
        "f23" => Some(KeyCode::KEY_F23),
        "f24" => Some(KeyCode::KEY_F24),
        "media_play_pause" => Some(KeyCode::KEY_PLAYPAUSE),
        "media_next" => Some(KeyCode::KEY_NEXTSONG),
        "media_prev" => Some(KeyCode::KEY_PREVIOUSSONG),
        "media_stop" => Some(KeyCode::KEY_STOPCD),
        "volume_up" => Some(KeyCode::KEY_VOLUMEUP),
        "volume_down" => Some(KeyCode::KEY_VOLUMEDOWN),
        "volume_mute" => Some(KeyCode::KEY_MUTE),
        _ => None,
    }
}

pub fn parse_ahk_file(path: &Path) -> Result<AhkConfig, String> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file: {}", e))?;
    
    let mut parser = AhkParser::new();
    parser.parse_file(&content)
}
